import React from 'react';
import styles from './styles/style.module.css';
import { AnimationType } from './interfaces/animations';
import { useIntersected } from './hooks/intersected';
import { slowAnimations } from './const/consts';
var CreateAnimateComponent = function (type) {
    var Component = function (_a) {
        var refEl = _a.refEl, children = _a.children, _b = _a.className, className = _b === void 0 ? [''] : _b, _c = _a.duration, duration = _c === void 0 ? slowAnimations.includes(type) ? 1.1 : 0.75 : _c, _d = _a.delay, delay = _d === void 0 ? 0 : _d, _e = _a.delayAfter, delayAfter = _e === void 0 ? 0 : _e, _f = _a.threshold, threshold = _f === void 0 ? 0.5 : _f, _g = _a.beforeAnimationClassName, beforeAnimationClassName = _g === void 0 ? '' : _g, _h = _a.afterAnimationClassName, afterAnimationClassName = _h === void 0 ? '' : _h, _j = _a.setOpacityNone, setOpacityNone = _j === void 0 ? false : _j, _k = _a.setOpacityNoneAfter, setOpacityNoneAfter = _k === void 0 ? false : _k, _l = _a.manualActive, manualActive = _l === void 0 ? false : _l, _m = _a.active, active = _m === void 0 ? false : _m, _o = _a.iterationCount, iterationCount = _o === void 0 ? 1 : _o, getRef = _a.getRef;
        var thisRef = React.useRef(null);
        var isIntersected = useIntersected({
            ref: refEl || thisRef,
            threshold: threshold
        })[0];
        var _p = React.useState(false), showAnimation = _p[0], setShowAnimation = _p[1];
        var _q = React.useState(false), showAfterClasses = _q[0], setShowAfterClasses = _q[1];
        var containerClasses = [
            styles['animate-container'],
            setOpacityNone && !showAnimation ? styles['animate-container__opacity-none'] : '',
            showAnimation ? styles["animate-container__".concat(type)] : beforeAnimationClassName,
            showAfterClasses ? afterAnimationClassName : '',
            setOpacityNoneAfter && showAfterClasses ? styles['animate-container__opacity-none'] : '',
            className,
        ].join(' ');
        React.useEffect(function () {
            if (isIntersected && !manualActive) {
                setTimeout(function () {
                    setShowAnimation(true);
                }, delay);
            }
        }, [delay, isIntersected, manualActive]);
        React.useEffect(function () {
            if (manualActive) {
                if (active) {
                    setTimeout(function () { return setShowAnimation(true); }, delay);
                }
                else {
                    setTimeout(function () { return setShowAnimation(false); }, delayAfter);
                }
            }
        }, [active, manualActive, delay, delayAfter]);
        React.useEffect(function () {
            if (getRef) {
                getRef(thisRef);
            }
        }, [thisRef, getRef]);
        React.useEffect(function () {
            if (showAnimation) {
                setTimeout(function () {
                    setShowAfterClasses(true);
                }, duration * 1000);
            }
        }, [showAnimation, duration]);
        return (React.createElement("div", { style: {
                animationDuration: "".concat(duration, "s"),
                animationIterationCount: iterationCount
            }, ref: thisRef, className: containerClasses }, children));
    };
    return Component;
};
var components = {};
Object.keys(AnimationType).forEach(function (key) {
    var name = key;
    components[name] = CreateAnimateComponent(key);
});
export var AnimateContainer = components;
//# sourceMappingURL=AnimateContainer.component.js.map