"use strict";
exports.__esModule = true;
exports.AnimateContainer = void 0;
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importDefault(require("react"));
var style_module_css_1 = tslib_1.__importDefault(require("./styles/style.module.css"));
var animations_1 = require("./interfaces/animations");
var intersected_1 = require("./hooks/intersected");
var consts_1 = require("./const/consts");
var CreateAnimateComponent = function (type) {
    var Component = function (_a) {
        var refEl = _a.refEl, children = _a.children, _b = _a.className, className = _b === void 0 ? [''] : _b, _c = _a.duration, duration = _c === void 0 ? consts_1.slowAnimations.includes(type) ? 1.1 : 0.75 : _c, _d = _a.delay, delay = _d === void 0 ? 0 : _d, _e = _a.delayAfter, delayAfter = _e === void 0 ? 0 : _e, _f = _a.threshold, threshold = _f === void 0 ? 0.5 : _f, _g = _a.beforeAnimationClassName, beforeAnimationClassName = _g === void 0 ? '' : _g, _h = _a.afterAnimationClassName, afterAnimationClassName = _h === void 0 ? '' : _h, _j = _a.setOpacityNone, setOpacityNone = _j === void 0 ? false : _j, _k = _a.setOpacityNoneAfter, setOpacityNoneAfter = _k === void 0 ? false : _k, _l = _a.manualActive, manualActive = _l === void 0 ? false : _l, _m = _a.active, active = _m === void 0 ? false : _m, _o = _a.iterationCount, iterationCount = _o === void 0 ? 1 : _o, getRef = _a.getRef;
        var thisRef = react_1["default"].useRef(null);
        var isIntersected = (0, intersected_1.useIntersected)({
            ref: refEl || thisRef,
            threshold: threshold
        })[0];
        var _p = react_1["default"].useState(false), showAnimation = _p[0], setShowAnimation = _p[1];
        var _q = react_1["default"].useState(false), showAfterClasses = _q[0], setShowAfterClasses = _q[1];
        var containerClasses = [
            style_module_css_1["default"]['animate-container'],
            setOpacityNone && !showAnimation ? style_module_css_1["default"]['animate-container__opacity-none'] : '',
            showAnimation ? style_module_css_1["default"]["animate-container__".concat(type)] : beforeAnimationClassName,
            showAfterClasses ? afterAnimationClassName : '',
            setOpacityNoneAfter && showAfterClasses ? style_module_css_1["default"]['animate-container__opacity-none'] : '',
            className,
        ].join(' ');
        react_1["default"].useEffect(function () {
            if (isIntersected && !manualActive) {
                setTimeout(function () {
                    setShowAnimation(true);
                }, delay);
            }
        }, [delay, isIntersected, manualActive]);
        react_1["default"].useEffect(function () {
            if (manualActive) {
                if (active) {
                    setTimeout(function () { return setShowAnimation(true); }, delay);
                }
                else {
                    setTimeout(function () { return setShowAnimation(false); }, delayAfter);
                }
            }
        }, [active, manualActive, delay, delayAfter]);
        react_1["default"].useEffect(function () {
            if (getRef) {
                getRef(thisRef);
            }
        }, [thisRef, getRef]);
        react_1["default"].useEffect(function () {
            if (showAnimation) {
                setTimeout(function () {
                    setShowAfterClasses(true);
                }, duration * 1000);
            }
        }, [showAnimation, duration]);
        return (react_1["default"].createElement("div", { style: {
                animationDuration: "".concat(duration, "s"),
                animationIterationCount: iterationCount
            }, ref: thisRef, className: containerClasses }, children));
    };
    return Component;
};
var components = {};
Object.keys(animations_1.AnimationType).forEach(function (key) {
    var name = key;
    components[name] = CreateAnimateComponent(key);
});
exports.AnimateContainer = components;
//# sourceMappingURL=AnimateContainer.component.js.map